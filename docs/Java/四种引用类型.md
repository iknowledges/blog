#### 强引用
java中默认声明的引用就是强引用，只要强引用存在，垃圾回收器就不会回收被引用的对象，如果想中断强引用和对象之间的联系，可以显示地将强引用赋值为null，这样JVM就能适时地回收对象了。
```java
Object obj = new Object();  // 不会回收
obj = null; // 可以回收
```
#### 软引用
软引用在系统内存充足时不会被回收，只有当系统内存不足时才会被回收。
```java
import java.lang.ref.SoftReference;
import java.util.ArrayList;
import java.util.List;

public class TestSoftReference {
    private static List<Object> list = new ArrayList<>();
    public static void main(String[] args) {
        for (int i=0; i<10; i++) {
            byte[] buff = new byte[1024*1024];
            SoftReference<byte[]> sr = new SoftReference<>(buff);
            list.add(sr);
        }
        System.gc(); //主动通知垃圾回收
        for (int i=0; i<list.size(); i++) {
            Object obj = ((SoftReference) list.get(i)).get();
            System.out.println(obj);
        }
    }
}
```

设置JVM内存：idea->Run/Dubug Configurations->VM options: -Xms2m -Xmx3m。
然后运行代码，结果打印出null。

#### 弱引用
弱引用比软引用的生存期更短，只要垃圾回收机制一运行，不管JVM的内存是否充足，总会回收该对象占用的内存。
```java
import java.lang.ref.WeakReference;
import java.util.ArrayList;
import java.util.List;

public class TestWeakReference {
    private static List<Object> list = new ArrayList<>();
    public static void main(String[] args) {
        for (int i=0; i<10; i++) {
            byte[] buff = new byte[1024*1024];
            WeakReference<byte[]> sr = new WeakReference<>(buff);
            list.add(sr);
        }
        System.gc(); //主动通知垃圾回收
        for (int i=0; i<list.size(); i++) {
            Object obj = ((WeakReference) list.get(i)).get();
            System.out.println(obj);
        }
    }
}
```
#### 虚引用
虚引用不能单独使用，必须和引用队列一起使用。虚引用的作用主要是跟踪对象被垃圾回收的状态。
```java
public class TestPhantomReference {
    private static boolean isRun = true;
    public static void main(String[] args) throw Exception {
        String abc = new String(“abc”); // 被监控的对象
        System.out.println(abc.getClass() + “@” + abc.hashCode());
        final ReferenceQueue<String> referenceQueue = new ReferenceQueue<String>();
        new Thread() {
            public void run() {
                while(isRun) {
                    Object obj = referenceQueue.poll();
                    if (obj != null) {
                        try {
                            Field referent = Reference.class.getDeclaredField(“referent”);
                            referent.setAccessible(true);
                            Object result = referent.get(obj);
                            System.out.println(“gc will collect: ” + result.getClass() 
                                + “@” + result.hashCode() + “\t” + (String) result);
                        } catch (Exception e) {
                            e.printStackTrace();
                        }
                    }
                }
            }
       	}.start();
        PhantomReference<String> abcWeakRef = new PhantomReference<String>(abc, referenceQueue);
        abc = null;
        Thread.currentThread().sleep(3000);
        System.gc(); //主动通知垃圾回收
        Thread.currentThread().sleep(3000);
        isRun = false;
    }
}
```
