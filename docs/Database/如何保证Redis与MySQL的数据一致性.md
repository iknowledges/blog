#### 方案一：先更新数据库，再更新缓存
如果先更新数据库再更新缓存，那么如果缓存更新失败，就会导致数据库和 Redis 中的是数据不一致的。

#### 方案二：先删除缓存，再更新数据库
如果是先删除缓存，再更新数据库，理想情况下是应用下次访问 Redis 的时候，发现 Redis 里面的数据是空的，那么就会从数据库加载保存到 Redis 里面，也就是说数据理论上是一致的，但是在极端情况下，由于删除 Redis 和更新数据库这两个操作并不是原子操作，所以在这个过程中如果其他线程来访问，还是会出现数据不一致的问题。

#### 方案三：先删除缓存，再更新数据库，再删除缓存（缓存延时双删）
先删除缓存，再更新数据库，然后休眠1s（根据具体业务合理设置，比如几百毫秒），再删除缓存。有可能第二次删除失败，还是会导致数据不一致。

#### 方案四：最终一致性方案（删除缓存重试机制）
高并发场景下采用先更新数据库，再删除缓存的方案，去保证 Redis 和 MySQL 数据的最终一致性。如果业务场景不能去接受数据的短期不一致，那么就不能使用这样的一个方案来实现。

为了保证缓存一定删除成功，可以基于 RabbitMQ 的重试机制来发送可靠性消息，还可以直接通过 Canal 组件监控 MySQL 里面的 binary log 日志，把更新后的数据同步到 Redis 里面。

[redis_mysql](drawio/redis_mysql.drawio ':include :type=code')
